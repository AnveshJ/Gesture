#include <stdio.h>  
#include <iostream>  
  
// #include <opencv2\opencv.hpp>  
#include <opencv/cv.h>
#include <opencv2/core/core.hpp>  
#include <opencv2/highgui/highgui.hpp>  
#include <opencv2/video/background_segm.hpp>  
  
  
#ifdef _DEBUG          
#pragma comment(lib, "opencv_core247d.lib")  
#pragma comment(lib, "opencv_imgproc247d.lib")   //MAT processing  
#pragma comment(lib, "opencv_objdetect247d.lib") //HOGDescriptor  
#pragma comment(lib, "opencv_gpu247d.lib")  
#pragma comment(lib, "opencv_features2d247d.lib")  
#pragma comment(lib, "opencv_highgui247d.lib")  
#pragma comment(lib, "opencv_ml247d.lib")  
#pragma comment(lib, "opencv_stitching247d.lib");  
#pragma comment(lib, "opencv_nonfree247d.lib");  
#pragma comment(lib, "opencv_video247d.lib")  
#else  
#pragma comment(lib, "opencv_core247.lib")  
#pragma comment(lib, "opencv_imgproc247.lib")  
#pragma comment(lib, "opencv_objdetect247.lib")  
#pragma comment(lib, "opencv_gpu247.lib")  
#pragma comment(lib, "opencv_features2d247.lib")  
#pragma comment(lib, "opencv_highgui247.lib")  
#pragma comment(lib, "opencv_ml247.lib")  
#pragma comment(lib, "opencv_stitching247.lib");  
#pragma comment(lib, "opencv_nonfree247.lib");  
#pragma comment(lib, "opencv_video247d.lib")  
#endif   
  
using namespace cv;  
using namespace std;  
  
  
  
int main()  
{  
  
 //global variables  
 Mat frame; //current frame  
 Mat resizeF;  
 Mat fgMaskMOG; //fg mask generated by MOG method  
 Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method  
 Mat fgMaskGMG; //fg mask fg mask generated by MOG2 method  
 vector<vector<Point> > contours;
vector<Vec4i> hierarchy;    
 Mat refinedimg;  



 Ptr< BackgroundSubtractor> pMOG; //MOG Background subtractor  
 Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor  
 Ptr< BackgroundSubtractorGMG> pGMG; //MOG2 Background subtractor  
   
  Moments moment;
  
 pMOG = new BackgroundSubtractorMOG();  
 pMOG2 = new BackgroundSubtractorMOG2();  
 pGMG = new BackgroundSubtractorGMG();  
   
  
 // char fileName[100] = "C:\\POSCO\\video\\/cctv 2.mov"; //Gate1_175_p1.avi"; //mm2.avi"; //";//_p1.avi";  
 VideoCapture stream1(0);   //0 is the id of video device.0 if you have only one camera     
  
 Mat element = getStructuringElement(MORPH_RECT, Size(3, 3), Point(1,1) );     
  namedWindow("frame", CV_WINDOW_AUTOSIZE);
 //unconditional loop     
 while (true) {     
  Mat cameraFrame;    

  if(!(stream1.read(frame))) //get one frame form video     
   break;  
    
  resize(frame, resizeF, Size(frame.size().width/4, frame.size().height/4) );  
  pMOG->operator()(frame, fgMaskMOG);  
  pMOG2->operator()(frame, fgMaskMOG2);  
  pGMG->operator()(frame, fgMaskGMG);  
  //morphologyEx(fgMaskGMG, fgMaskGMG, CV_MOP_OPEN, element);   
  
   
  
  
  imshow("Origin", resizeF);  
  imshow("MOG", fgMaskMOG);  
  imshow("MOG2", fgMaskMOG2);  
  imshow("GMG", fgMaskGMG);  
    
  // filterImage(fgMaskMOG2);
    medianBlur(fgMaskMOG2,fgMaskMOG2,15);



    Canny(fgMaskMOG2,refinedimg,50,200,3);
    findContours(refinedimg,contours,hierarchy,CV_RETR_TREE,CV_CHAIN_APPROX_SIMPLE,Point(0,0));
vector<vector<Point> > hull(contours.size());
  vector<vector<int> > hulldf(contours.size());
  vector<vector<Point> > contours_poly(contours.size());
  vector<vector<Vec4i> > defects(contours.size());
  

    for(int j=0;j < contours.size();j++)
    {
            approxPolyDP(contours[j],contours_poly[j],5,true);
    
        // approxPolyDP(contours[j],contours_poly[j],5,true);
    }
    // for(int k=0;k<contours.size();k++)
    // {
    //     convexHull(contours_poly[k],hull[k],false);
    //     convexHull(contours_poly[k],hulldf[k],false);
    //     if(hulldf.size()>100)
    //     {
    //         convexityDefects(contours[k],hulldf[k],defects[k]);
    //     }
    // }

    for(int i=0;i<contours.size();i++)
    {
        drawContours( frame, contours_poly, i, Scalar(0,255,0), 2, 8, hierarchy, 0, Point() );
        drawContours( frame, hull, i,Scalar(255,0,0),2,8, hierarchy,0,Point());
    }



   //  int j, maxindex, maxarea=0, area,x , y;
   //    // float prm;
   //          for(j=0; j< contours_poly.size(); j++)
   //          {
   //              moment = moments((Mat)contours_poly.at(j));
   //              area= moment.m00;
   //              if(area>maxarea)
   //              {
   //                  maxarea = area;
   //                  maxindex = j;
   //              }
   //          }
      
   //          contours_poly.resize(1);

   // int y_min=240,y_min_index = 0;
   //       int k=0;
   //       while(k < contours_poly[0].size()){
   //         if(contours_poly[0][k].y < y_min){
   //           y_min = contours_poly[0][k].y;
   //           y_min_index = k;
   //         }
   //         k++;
   //       }


    imshow("frame", frame);
  if (waitKey(30) >= 0)     
   break;     
 }  
  return -1;
}  